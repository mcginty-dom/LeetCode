package com.company;

public class Path {

    //UNIQUE PATHS

    //Medium - https://leetcode.com/problems/unique-paths/
    public int uniquePaths(int m, int n) {

    }

    //Medium - https://leetcode.com/problems/unique-paths-ii/
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {

    }

    //Hard - https://leetcode.com/problems/unique-paths-iii/
    public int uniquePathsIII(int[][] grid) {

    }

    //SHORTEST PATHS

    //Medium - https://leetcode.com/problems/shortest-path-in-binary-matrix/
    public int shortestPathBinaryMatrix(int[][] grid) {

    }

    //Medium - https://leetcode.com/problems/minimum-path-sum/
    public int minPathSum(int[][] grid) {

    }

    //Medium - https://leetcode.com/problems/path-with-minimum-effort/
    public int minimumEffortPath(int[][] heights) {

    }

    //Hard - https://leetcode.com/problems/shortest-path-to-get-all-keys/
    public int shortestPathAllKeys(String[] grid) {

    }

    //Hard - https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/
    public int shortestPath(int[][] grid, int k) {

    }

    //LONGEST PATHS

    //Medium - https://leetcode.com/problems/path-with-maximum-gold/
    public int getMaximumGold(int[][] grid) {

    }

    //Hard - https://leetcode.com/problems/longest-increasing-path-in-a-matrix/
    public int longestIncreasingPath(int[][] matrix) {

    }

    //VALID PATHS

    //Easy - https://leetcode.com/problems/path-crossing/
    public boolean isPathCrossing(String path) {

    }

    //Easy - https://leetcode.com/problems/find-if-path-exists-in-graph/
    public boolean validPath(int n, int[][] edges, int start, int end) {

    }

    //Medium - https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/
    public boolean hasValidPath(int[][] grid) {

    }

    //Medium - https://leetcode.com/problems/path-with-maximum-probability/
    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {

    }

}
